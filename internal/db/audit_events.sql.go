// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: audit_events.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const adminCountAuditEvents = `-- name: AdminCountAuditEvents :one
SELECT COUNT(*)
FROM audit_events e
LEFT JOIN users u ON u.id = e.actor_user_id
LEFT JOIN api_keys k ON k.id = e.actor_api_key_id
LEFT JOIN tenants t ON t.id = e.tenant_id
WHERE
  ($1 = '' OR
    e.action ILIKE '%' || $1 || '%' OR
    COALESCE(e.resource_type, '') ILIKE '%' || $1 || '%' OR
    COALESCE(e.resource_id, '') ILIKE '%' || $1 || '%' OR
    COALESCE(u.email, '') ILIKE '%' || $1 || '%' OR
    COALESCE(u.name, '') ILIKE '%' || $1 || '%' OR
    COALESCE(k.label, '') ILIKE '%' || $1 || '%' OR
    COALESCE(t.name, '') ILIKE '%' || $1 || '%' OR
    COALESCE(t.slug, '') ILIKE '%' || $1 || '%'
  )
  AND ($2 = '' OR e.action = $2)
  AND (NOT $3 OR e.tenant_id = $4)
  AND (NOT $5 OR e.actor_user_id = $6)
  AND (NOT $7 OR e.actor_api_key_id = $8)
  AND (NOT $9 OR e.created_at >= $10)
  AND (
    $11 = '' OR
    ($11 = 'api_key' AND e.actor_api_key_id IS NOT NULL) OR
    ($11 = 'session' AND e.actor_api_key_id IS NULL AND e.actor_user_id IS NOT NULL)
  )
`

type AdminCountAuditEventsParams struct {
	Column1       interface{}
	Column2       interface{}
	Column3       interface{}
	TenantID      uuid.NullUUID
	Column5       interface{}
	ActorUserID   uuid.NullUUID
	Column7       interface{}
	ActorApiKeyID uuid.NullUUID
	Column9       interface{}
	CreatedAt     time.Time
	Column11      interface{}
}

func (q *Queries) AdminCountAuditEvents(ctx context.Context, arg AdminCountAuditEventsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, adminCountAuditEvents,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.TenantID,
		arg.Column5,
		arg.ActorUserID,
		arg.Column7,
		arg.ActorApiKeyID,
		arg.Column9,
		arg.CreatedAt,
		arg.Column11,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const adminListAuditEvents = `-- name: AdminListAuditEvents :many
SELECT
  e.id,
  e.created_at,
  e.action,
  e.actor_user_id,
  e.actor_api_key_id,
  e.tenant_id,
  e.resource_type,
  e.resource_id,
  e.ip,
  e.user_agent,
  e.metadata,
  u.email AS actor_user_email,
  u.name AS actor_user_name,
  k.label AS actor_api_key_label,
  t.name AS tenant_name,
  t.slug AS tenant_slug,
  t.type AS tenant_type
FROM audit_events e
LEFT JOIN users u ON u.id = e.actor_user_id
LEFT JOIN api_keys k ON k.id = e.actor_api_key_id
LEFT JOIN tenants t ON t.id = e.tenant_id
WHERE
  ($1 = '' OR
    e.action ILIKE '%' || $1 || '%' OR
    COALESCE(e.resource_type, '') ILIKE '%' || $1 || '%' OR
    COALESCE(e.resource_id, '') ILIKE '%' || $1 || '%' OR
    COALESCE(u.email, '') ILIKE '%' || $1 || '%' OR
    COALESCE(u.name, '') ILIKE '%' || $1 || '%' OR
    COALESCE(k.label, '') ILIKE '%' || $1 || '%' OR
    COALESCE(t.name, '') ILIKE '%' || $1 || '%' OR
    COALESCE(t.slug, '') ILIKE '%' || $1 || '%'
  )
  AND ($2 = '' OR e.action = $2)
  AND (NOT $3 OR e.tenant_id = $4)
  AND (NOT $5 OR e.actor_user_id = $6)
  AND (NOT $7 OR e.actor_api_key_id = $8)
  AND (NOT $9 OR e.created_at >= $10)
  AND (
    $11 = '' OR
    ($11 = 'api_key' AND e.actor_api_key_id IS NOT NULL) OR
    ($11 = 'session' AND e.actor_api_key_id IS NULL AND e.actor_user_id IS NOT NULL)
  )
ORDER BY e.created_at DESC
LIMIT $12 OFFSET $13
`

type AdminListAuditEventsParams struct {
	Column1       interface{}
	Column2       interface{}
	Column3       interface{}
	TenantID      uuid.NullUUID
	Column5       interface{}
	ActorUserID   uuid.NullUUID
	Column7       interface{}
	ActorApiKeyID uuid.NullUUID
	Column9       interface{}
	CreatedAt     time.Time
	Column11      interface{}
	Limit         int32
	Offset        int32
}

type AdminListAuditEventsRow struct {
	ID               int64
	CreatedAt        time.Time
	Action           string
	ActorUserID      uuid.NullUUID
	ActorApiKeyID    uuid.NullUUID
	TenantID         uuid.NullUUID
	ResourceType     sql.NullString
	ResourceID       sql.NullString
	Ip               sql.NullString
	UserAgent        sql.NullString
	Metadata         json.RawMessage
	ActorUserEmail   sql.NullString
	ActorUserName    sql.NullString
	ActorApiKeyLabel sql.NullString
	TenantName       sql.NullString
	TenantSlug       sql.NullString
	TenantType       sql.NullString
}

func (q *Queries) AdminListAuditEvents(ctx context.Context, arg AdminListAuditEventsParams) ([]AdminListAuditEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, adminListAuditEvents,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.TenantID,
		arg.Column5,
		arg.ActorUserID,
		arg.Column7,
		arg.ActorApiKeyID,
		arg.Column9,
		arg.CreatedAt,
		arg.Column11,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AdminListAuditEventsRow
	for rows.Next() {
		var i AdminListAuditEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.Action,
			&i.ActorUserID,
			&i.ActorApiKeyID,
			&i.TenantID,
			&i.ResourceType,
			&i.ResourceID,
			&i.Ip,
			&i.UserAgent,
			&i.Metadata,
			&i.ActorUserEmail,
			&i.ActorUserName,
			&i.ActorApiKeyLabel,
			&i.TenantName,
			&i.TenantSlug,
			&i.TenantType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAuditEvent = `-- name: InsertAuditEvent :one
INSERT INTO audit_events (
  action,
  actor_user_id,
  actor_api_key_id,
  tenant_id,
  resource_type,
  resource_id,
  ip,
  user_agent,
  metadata
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, created_at, action, actor_user_id, actor_api_key_id, tenant_id, resource_type, resource_id, ip, user_agent, metadata
`

type InsertAuditEventParams struct {
	Action        string
	ActorUserID   uuid.NullUUID
	ActorApiKeyID uuid.NullUUID
	TenantID      uuid.NullUUID
	ResourceType  sql.NullString
	ResourceID    sql.NullString
	Ip            sql.NullString
	UserAgent     sql.NullString
	Metadata      json.RawMessage
}

func (q *Queries) InsertAuditEvent(ctx context.Context, arg InsertAuditEventParams) (AuditEvent, error) {
	row := q.db.QueryRowContext(ctx, insertAuditEvent,
		arg.Action,
		arg.ActorUserID,
		arg.ActorApiKeyID,
		arg.TenantID,
		arg.ResourceType,
		arg.ResourceID,
		arg.Ip,
		arg.UserAgent,
		arg.Metadata,
	)
	var i AuditEvent
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Action,
		&i.ActorUserID,
		&i.ActorApiKeyID,
		&i.TenantID,
		&i.ResourceType,
		&i.ResourceID,
		&i.Ip,
		&i.UserAgent,
		&i.Metadata,
	)
	return i, err
}
